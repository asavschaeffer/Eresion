# eresion_core/tokenization/tokenizer.py
"""
Core tokenizer for the Eresion headless system.

This module generates rich contextual tokens from the game state snapshot,
supplementing the action tokens generated by the game head.
"""

import time
from typing import List, Set, Dict, Any
from shared.interfaces import Token, TokenType, ITokenizer, IGameBridge

class StreamlinedTokenizer(ITokenizer):
    """
    Generates contextual tokens from the game state.
    
    This tokenizer focuses on extracting meaningful information from the overall
    game state (environment, resources, social, biometric) to provide context
    for pattern emergence.
    """
    
    def __init__(self):
        self.known_token_types = self._define_token_types()
    
    def _define_token_types(self) -> Set[TokenType]:
        """Define the core token types used for pattern emergence."""
        return {
            # Action-based tokens (primary fuel for emergence)
            "ATTACK_ACTION",
            "DASH_ACTION", 
            "DODGE_ACTION",
            "INFLUENCE_ACTION",
            "READY_ACTION",
            "REST_ACTION",
            
            # Behavioral signature tokens
            "BEHAVIORAL_SIGNATURE",
            "MODIFIER_APPLICATION",
            "TARGET_INTERACTION",
            
            # Context tokens (environmental and situational)
            "LOCATION_CHANGE",
            "RESOURCE_STATE",
            "COMBAT_STATE",
            "SOCIAL_STATE",
            
            # Pattern tokens (higher-level abstractions)
            "ACTION_SEQUENCE",
            "TACTICAL_CHOICE",
            "RISK_ASSESSMENT",
            "SOCIAL_APPROACH"
        }
    
    def get_known_token_types(self) -> Set[TokenType]:
        """Return all token types this tokenizer can produce."""
        return self.known_token_types

    def process_game_event(self, event: Dict) -> List[Token]:
        """Processes a single raw event from the game engine."""
        # This is a legacy method from the ITokenizer interface.
        # The new architecture generates action-specific tokens directly
        # within the game head (e.g., in the DnDGameEngine).
        # This implementation ensures compatibility with the interface.
        return []
    
    def process_world_state(self, bridge: IGameBridge) -> List[Token]:
        """
        Generate tokens from a game state via the bridge.
        
        This creates contextual tokens to supplement the rich action tokens
        generated by the game head.
        """
        tokens = []
        current_time = time.time()
        game_state = bridge.get_all_state_snapshot()
        player_state = game_state['player']
        
        # 1. Location context token
        tokens.append(self._create_location_token(game_state, current_time))
        
        # 2. Resource state token
        tokens.append(self._create_resource_token(game_state, current_time))
        
        # 3. Combat context token (if relevant)
        if player_state.get('in_combat', False):
            tokens.append(self._create_combat_token(game_state, current_time))
        
        # 4. Social context token (if relevant)
        if game_state.get('social', {}).get('recent_conversations'):
            tokens.append(self._create_social_token(game_state, current_time))
        
        # 5. Environmental context token
        tokens.append(self._create_environmental_token(game_state, current_time))
        
        return tokens
    
    def _create_location_token(self, game_state: Dict[str, Any], timestamp: float) -> Token:
        """Create location context token."""
        env_state = game_state.get('environment', {})
        player_state = game_state.get('player', {})
        return Token(
            type="LOCATION_CHANGE",
            timestamp_s=timestamp,
            metadata={
                "domain": "context",
                "current_location": player_state.get('location'),
                "previous_location": player_state.get('previous_location'),
                "location_type": self._classify_location(player_state.get('location', '')),
                "safety_level": self._assess_location_safety(game_state),
                "entities_present": len(env_state.get('current_location_entities', []))
            }
        )
    
    def _create_resource_token(self, game_state: Dict[str, Any], timestamp: float) -> Token:
        """Create resource state token."""
        player_state = game_state.get('player', {})
        health = player_state.get('health_percent', 1.0)
        stamina = player_state.get('stamina_percent', 1.0)
        health_category = self._categorize_resource(health)
        stamina_category = self._categorize_resource(stamina)
        
        return Token(
            type="RESOURCE_STATE",
            timestamp_s=timestamp,
            metadata={
                "domain": "context",
                "health_percent": health,
                "stamina_percent": stamina,
                "health_category": health_category,
                "stamina_category": stamina_category,
                "resource_pressure": self._calculate_resource_pressure(game_state),
                "buff_count": len(player_state.get('active_buffs', []))
            }
        )
    
    def _create_combat_token(self, game_state: Dict[str, Any], timestamp: float) -> Token:
        """Create combat context token."""
        player_state = game_state.get('player', {})
        env_state = game_state.get('environment', {})
        hostile_entities = [e for e in env_state.get('current_location_entities', {}).values() if e.get('is_hostile')]
        
        return Token(
            type="COMBAT_STATE",
            timestamp_s=timestamp,
            metadata={
                "domain": "context",
                "in_combat": True,
                "hostile_count": len(hostile_entities),
                "player_health": player_state.get('health_percent', 1.0),
                "player_stamina": player_state.get('stamina_percent', 1.0),
                "threat_level": self._assess_threat_level(hostile_entities, game_state),
                "combat_duration": player_state.get('combat_duration', 0)
            }
        )
    
    def _create_social_token(self, game_state: Dict[str, Any], timestamp: float) -> Token:
        """Create social context token."""
        social_state = game_state.get('social', {})
        recent_conv = social_state.get('recent_conversations', [])[-1] if social_state.get('recent_conversations') else {}
        
        return Token(
            type="SOCIAL_STATE",
            timestamp_s=timestamp,
            metadata={
                "domain": "context",
                "recent_conversation_target": recent_conv.get("npc", ""),
                "recent_conversation_outcome": recent_conv.get("outcome", ""),
                "total_relationships": len(social_state.get('relationship_scores', {})),
                "average_relationship": self._calculate_average_relationship(game_state),
                "social_activity_level": len(social_state.get('recent_conversations', []))
            }
        )
    
    def _create_environmental_token(self, game_state: Dict[str, Any], timestamp: float) -> Token:
        """Create environmental context token."""
        env_state = game_state.get('environment', {})
        temporal_state = game_state.get('temporal', {})
        return Token(
            type="ENVIRONMENTAL_CONTEXT",
            timestamp_s=timestamp,
            metadata={
                "domain": "context",
                "weather": env_state.get('weather'),
                "time_of_day": env_state.get('time_of_day'),
                "turn_number": temporal_state.get('turn'),
                "session_number": temporal_state.get('session', 1),
                "environmental_pressure": self._calculate_environmental_pressure(game_state)
            }
        )
    
    def process_action_tokens(self, action_tokens: List[Token]) -> List[Token]:
        """
        Process and enrich action tokens generated by D&D actions.
        
        This adds higher-level pattern tokens derived from action sequences.
        """
        enriched_tokens = action_tokens.copy()
        
        # Add tactical choice analysis
        tactical_token = self._analyze_tactical_choice(action_tokens)
        if tactical_token:
            enriched_tokens.append(tactical_token)
        
        # Add risk assessment analysis  
        risk_token = self._analyze_risk_assessment(action_tokens)
        if risk_token:
            enriched_tokens.append(risk_token)
        
        return enriched_tokens
    
    def _analyze_tactical_choice(self, action_tokens: List[Token]) -> Token:
        """Analyze tactical patterns in recent actions."""
        if not action_tokens:
            return None
        
        # Look for primary action token
        action_token = None
        for token in action_tokens:
            if token.type.endswith("_ACTION"):
                action_token = token
                break
        
        if not action_token:
            return None
        
        # Analyze tactical context
        action_type = action_token.type.replace("_ACTION", "")
        success = action_token.metadata.get("success", False)
        modifier = action_token.metadata.get("adjective_primitive", "NORMAL")
        
        tactical_pattern = self._classify_tactical_pattern(action_type, modifier, success)
        
        return Token(
            type="TACTICAL_CHOICE",
            timestamp_s=time.time(),
            metadata={
                "domain": "pattern",
                "base_action": action_type,
                "modifier_used": modifier,
                "tactical_pattern": tactical_pattern,
                "success_outcome": success,
                "pattern_confidence": 0.8
            }
        )
    
    def _analyze_risk_assessment(self, action_tokens: List[Token]) -> Token:
        """Analyze risk-taking patterns in actions."""
        if not action_tokens:
            return None
        
        # Find behavioral signature token
        behavior_token = None
        for token in action_tokens:
            if token.type == "BEHAVIORAL_SIGNATURE":
                behavior_token = token
                break
        
        if not behavior_token:
            return None
        
        risk_tolerance = behavior_token.metadata.get("risk_tolerance", 0.0)
        aggression = behavior_token.metadata.get("aggression", 0.0)
        
        risk_category = self._classify_risk_taking(risk_tolerance, aggression)
        
        return Token(
            type="RISK_ASSESSMENT",
            timestamp_s=time.time(),
            metadata={
                "domain": "pattern",
                "risk_tolerance": risk_tolerance,
                "aggression": aggression,
                "risk_category": risk_category,
                "calculated_risk": risk_tolerance + (aggression * 0.5)
            }
        )
    
    # ========================================================================
    # UTILITY METHODS
    # ========================================================================
    
    def _classify_location(self, location: str) -> str:
        """Classify location by type."""
        if "town" in location.lower():
            return "settlement"
        elif "forest" in location.lower():
            return "wilderness"
        elif "cave" in location.lower():
            return "underground"
        elif "ruins" in location.lower():
            return "ancient"
        else:
            return "unknown"
    
    def _assess_location_safety(self, game_state: Dict[str, Any]) -> float:
        """Assess safety level of current location (0.0 = dangerous, 1.0 = safe)."""
        hostile_count = len([e for e in game_state.environment.current_location_entities.values() if e.is_hostile])
        
        if game_state.player.location == "Town Square":
            return 1.0 - (hostile_count * 0.1)
        elif "forest" in game_state.player.location.lower():
            return max(0.0, 0.3 - (hostile_count * 0.2))
        else:
            return max(0.0, 0.5 - (hostile_count * 0.15))
    
    def _categorize_resource(self, resource_percent: float) -> str:
        """Categorize resource level."""
        if resource_percent >= 0.8:
            return "high"
        elif resource_percent >= 0.5:
            return "medium"
        elif resource_percent >= 0.2:
            return "low"
        else:
            return "critical"
    
    def _calculate_resource_pressure(self, game_state: Dict[str, Any]) -> float:
        """Calculate overall resource pressure (0.0 = no pressure, 1.0 = extreme pressure)."""
        health_pressure = 1.0 - game_state.player.health_percent
        stamina_pressure = 1.0 - game_state.player.stamina_percent
        
        # Weight health pressure more heavily
        return (health_pressure * 0.7) + (stamina_pressure * 0.3)
    
    def _assess_threat_level(self, hostile_entities: List, game_state: Dict[str, Any]) -> float:
        """Assess current threat level (0.0 = no threat, 1.0 = extreme threat)."""
        if not hostile_entities:
            return 0.0
        
        # Base threat from entity count
        threat = min(1.0, len(hostile_entities) * 0.3)
        
        # Increase threat if player is injured
        if game_state.player.health_percent < 0.5:
            threat *= 1.5
        
        # Increase threat if player is exhausted
        if game_state.player.stamina_percent < 0.3:
            threat *= 1.3
        
        return min(1.0, threat)
    
    def _calculate_average_relationship(self, game_state: Dict[str, Any]) -> float:
        """Calculate average relationship score."""
        scores = game_state.social.relationship_scores
        if not scores:
            return 0.0
        
        return sum(scores.values()) / len(scores)
    
    def _calculate_environmental_pressure(self, game_state: Dict[str, Any]) -> float:
        """Calculate environmental pressure from weather, time, etc."""
        pressure = 0.0
        
        # Weather pressure
        if game_state.environment.weather == "Stormy":
            pressure += 0.3
        elif game_state.environment.weather == "Overcast":
            pressure += 0.1
        
        # Time pressure
        if game_state.environment.time_of_day in ["Night", "Midnight"]:
            pressure += 0.2
        
        return min(1.0, pressure)
    
    def _classify_tactical_pattern(self, action_type: str, modifier: str, success: bool) -> str:
        """Classify tactical pattern from action."""
        if modifier == "CAUTIOUS":
            return "defensive_careful"
        elif modifier == "QUICK" and action_type == "ATTACK":
            return "aggressive_rush"
        elif modifier == "POWERFUL":
            return "overwhelming_force"
        elif action_type == "DODGE" or action_type == "REST":
            return "recovery_focused"
        elif action_type == "INFLUENCE":
            return "diplomatic_approach"
        else:
            return "standard_approach"
    
    def _classify_risk_taking(self, risk_tolerance: float, aggression: float) -> str:
        """Classify risk-taking behavior."""
        combined_risk = risk_tolerance + (aggression * 0.5)
        
        if combined_risk >= 0.7:
            return "high_risk_taker"
        elif combined_risk >= 0.3:
            return "moderate_risk_taker"
        elif combined_risk >= -0.3:
            return "cautious_player"
        else:
            return "risk_averse"


